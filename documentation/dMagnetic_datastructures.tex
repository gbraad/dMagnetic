\documentclass[11pt,twoside,openright]{report}
\newcommand{\titlename}{Data structures}
\usepackage{commands}
\usepackage{verbatimbox}
\renewcommand*\rmdefault{pag}
\renewcommand*\sfdefault{pag}
\renewcommand*\ttdefault{pcr}
\begin{document}
\title{dMagnetic- Data structures}
\author{dettus@dettus.net}
\date{December 27th, 2019}
\maketitle
{\tiny
\begin{verbatim}
Copyright (c) 2019, Thomas Dettbarn
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end{verbatim}
}
\tableofcontents
\newpage
\chapter{Introduction}
The purpose of this document is to describe the data structures that were used by the original programmers of the Magnetic Scroll Adventures. It is less an exhaustive description, but more of a documentation as on how they where interpreted for the implementation of \dmagnetic.
\section{Nomenclature}
The Interpreter implemented a virtual 68000 processor. That particular CPU has three data types:
\begin{description}
\item[BYTE]{8 bits}
\item[WORD]{16 bits}
\item[LONG]{32 bits}
\end{description}
Unless otherwise stated, all values are stored as BIG endian, meaning that higher bits are stored at a lower address. The value 0x01020304 is thus stored in 4 consequitive bytes as 01 02 03 04.
\chapter{Binary File formats}
\section{MAG file format}
The game itself is stored in a file with the ending {\tt .mag}. It has the following structure:

\begin{tabular}{l|l}
Bytes&Description\\
0..3&"MaSc", the magic header\\
4..12&UNKNOWN\\
13&Version. 0=The Pawn\\
&1= The Guild of Thieves.\\
&2..\\
14..17&Size of the Game code\\
18..21&Size of the String 1 section\\
22..25&Size of the String 2 section\\
26..29&Size of the Dictionary section\\
30..33&Size of the Dec(??) section\\
34..37&Size of the Undo(??) section\\
38..41&Undo PC(??)\\\hline
\end{tabular}

Afterwards the Code, String, Dictionary, Dec, Undo Sections follow.
\section{GFX file format, Version 1}
\begin{tabular}{l|l}
Bytes&Description\\\hline
0..3&"MaPi", the magic header\\
4..7&UNKNOWN\\
8..12&Indexpointer to Picture 0\\
13..15&Indexpointer to Picture 1\\
...&...\\
\end{tabular}

At the byte that the pointer is denoting, the picture itself is stored as such:

\begin{tabular}{l|l|ll}
Bytes&Bits&Description\\\hline
0..1&&UNKNOWN\\
2..3&&X1\\
4..5&&X2. the {\bf width} is X2-X1.&$width$\\
6..7&&height\\
8..27&&UNKNOWN\\
28..29&&RGB value for pixel=0.&$pal_0$\\
&11..8&red\\
&7..4&green\\
&3..0&blue\\
31..34&&RGB value for pixel=1.&$pal_1$\\
..&&&\\
58..59&&RGB vlaue for pixel=15.&$pal_{15}$\\
60..61&&Size of the Huffman table (in bytes)&$HT$\\
62..65&&Size of the Data bit stream (in bytes)&$BS$\\\hline
\end{tabular}

Afterwards, a Huffman table follows. Then a section of bit streams.\\
\subsection{Symbols in the Huffman Table}
Symbols in the Huffman Table are either non-terminal symbols, pointing to the next entry, or terminal ones. Terminal entries have bit 7 set.\\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\tiny 7&\tiny 6&\tiny 5&\tiny 4&\tiny 3&\tiny 2&\tiny 1&\tiny 0\\\hline
0&\multicolumn{7}{c|}{index pointer}\\\hline
1&\multicolumn{3}{c|}{repeat}&\multicolumn{4}{c|}{pixel}\\\hline
\end{tabular}

The data structure is a tree. Decoding the table starts at the very last one, at Byte $66+(HT-1)=ptr$. 

\subsection{Bits in the Bitstream}
Decoding of the Pixels is MSB first, so it starts at Byte $66+HT+BS$ with Bit 7 at the beginning of Bitstream block. If it is a 1, the entry in the Huffman Table $h(ptr)=e$ is being evaluated, otherwise $h(ptr+1)=e$.
\subsection{Decoding the pixels}
If the retrieved entry $e$ is a non terminal symbol, the new pointer $ptr$ is evaluated as $ptr^\prime=66+2\cdot e$.\\
If it is terminal symbol, and $repeat=0$, the pixel has been decoded as $p_j=pixel(e)$. The pointer is reset to the end of the Huffman table $ptr^\prime=66+HT-1$\\
If it is terminal symbol, and $repeat\ne 0$, the previous pixel is being used again, $p_j=p_{j-1}$. Afterwards, the repeat and the pixel section are being decremented. $repeat(e)^\prime=repeat(e)-1$ and $pixel(e)^\prime=pixel(e)-1$. If this results in $pixel(e)^\prime=0$, the pointer is being reset to the end of the Huffmann Table $ptr^\prime=66+HT-1$.\\

Once all the pixels in a line have been decoded, they are being XORed with the previous line:
\begin{eqnarray*}
p_j^\prime&=&p_j\oplus p_{j-width}\\
\end{eqnarray*}
\subsection{Rendering the pixels}
The RGB values for the pixel are stored in the palette. To render it properly, each pixels RGB value can be drawn as 
\begin{eqnarray*}
rgb_j&=&pal(p_j^\prime)\\
\end{eqnarray*}
It should be noted that even tough the entries in the palette are 12 bits wide, the red, green and blue values are only $\in\left[0..7\right]$.\\
\section{GFX file format, Version 2}
The CD collection games, and Wonderland, used a different format for storing pictures.\\
The .gfx files start with a directory, afterwards the images or animations are being stored as a bitmap-oriented structure.\\

\beginpicture
\setcoordinatesystem units <5ex,5ex>
\setplotarea x from 0 to 6, y from 0 to 6
\plot 0 1 0 5 5 5 5 1 /
\plot 0 4 5 4 /
\plot 0 2.5 5 2.5 /
\plot 0 1.25 5 1.25 /
\setshadegrid span <1pt>
\hshade 4 0 5 5 0 5 /
\setshadegrid span <2pt>
\hshade 2.5 0 5 4 0 5 /
\put {'M'} at 1 5.25
\put {'a'} at 2 5.25
\put {'P'} at 3 5.25
\put {'2'} at 4 5.25
\put {Directory} at 2.5 4.5
\put {Picture 1} at 2.5 3.25
\put {Picture 2} at 2.5 1.9

\endpicture

{\bf IT SHOULD ALSO BE NOTED THAT THE DATA FORMAT IS SOMETIMES LITTLE-ENDIAN INSTEAD OF BIG ENDIAN!}
\subsection{16 bit/32 bit}
16 bit values are stored as little endians, some 32 bit values are stored as {\bf MIXED} endians.\\
\begin{center}
\begin{tabular}{l|l|r|r}
Bytes&Hex value&Dec value\\\hline
little endian&{\tt 12 3E}&$0x3e12$&15890\\
mixed endian&{\tt 1A 2B 3C 4D}&$0x2b1a4d3c$&723143996\\
BIG endian&{\tt 5A 6B 7C 8D}&$0x5a6b7c8d$&1516993677\\
\end{tabular}
\end{center}

\subsection{Directory}
After the magic header "MaP2", the size of the directory is stored as 16 bit {\bf little endian}. Entries are 16 bytes long.\\
\begin{tabular}{rr|l}
Bytes&&Description\\\hline
0..3&&"MaP2"\\\hline
4..5&&Length of the Directory (in bytes), BIG ENDIAN\\\hline
6..21&&Entry 1\\
&6..13&Filename (case insensitive, zero-terminated)\\
&14..17&Offset within the file (BIG ENDIAN)\\
&18..21&Length of the picture in bytes (BIG ENDIAN)\\\hline
22..37&&Entry 2\\
...
\end{tabular}
\subsection{Static pictures}
Once the filename has been resolved, the size of the picture in bytes, as well as its offset is known.\\
\begin{tabular}{r|rl}
Bytes&&Description\\\hline
offset+4..offset+5&RGB(0)&RGB value pixel 0 (little endian)\\
offset+6..offset+7&RGB(1)&RGB value pixel 1 (little endian)\\
....&&\\
offset+36..offset+37&RGB(15)&RGB value pixel 15 (little endian)\\\hline
38..41&$datasize$& of the bitmap in bytes, MIXED ENDIAN\\
42..43&$width$& in pixels, little endian\\
44..45&$height$& in pixels, little endian\\
46..47&&UNKNOWN\\
48..47+datasize&bitmap\\\hline
48+datasize..49+datasize&"D0 5E"&identifies static pictures.
\end{tabular}
\subsubsection{RGB values}
RGB values are stored as 12 bits in a 16 bit little endian value.
The bytes 53 01 become the value 0x0153, meaning RED=1, GREEN=5, BLUE=3.\\
\subsubsection{Bitmap}
The Bitmap is organized in lines. Each pixel 0..15 can be represented by 4 bits: 3210. In each line, the bits are lumped together, beginning with bit 0 of the first pixel. Then Bit 0 of the second pixel, then bit 0 of the third and so on. (MSB first).\\
The bit groups are byte aligned; when the number of pixel in each line is NOT divisible by 8, the lower bits of the last byte are padding. Afterwards, the block for bit 1 starts. Then padding, then Bit 2, then padding, then Bit 3.\\

The Bitmap for a picture that is 5 pixels wide and 4 pixel requires 16 Bytes:\\
\begin{tabular}{ll|ll|ll|lll}
{\tt 00000}&{\tt ppp}&{\tt 11111}&{\tt ppp}&{\tt 22222}&{\tt ppp}&{\tt 33333}&{\tt ppp}&Line 1\\\hline
{\tt 00000}&{\tt ppp}&{\tt 11111}&{\tt ppp}&{\tt 22222}&{\tt ppp}&{\tt 33333}&{\tt ppp}&Line 2\\\hline
{\tt 00000}&{\tt ppp}&{\tt 11111}&{\tt ppp}&{\tt 22222}&{\tt ppp}&{\tt 33333}&{\tt ppp}&Line 3\\\hline
{\tt 00000}&{\tt ppp}&{\tt 11111}&{\tt ppp}&{\tt 22222}&{\tt ppp}&{\tt 33333}&{\tt ppp}&Line 4\\
\end{tabular}

In this example: $datasize=16$, $width=5$ and $height=4$.\\
\subsubsection{Decoding and rendering}
To decode a pixel $p$, the bits $b_0,\;b_1,\;b_2,\;b_3$ have to be combined:\\
\begin{eqnarray*}
p_j&=&1\cdot b_0(j)+2\cdot b_1(j)+4\cdot b_2(j)+8\cdot b_3(j)\\
\end{eqnarray*}
The resulting $p_j$ is the index pointer into the RGB table.\\
\begin{eqnarray*}
rgb(j)&=&RGB(p_j)
\end{eqnarray*}
Obviously, $rgb_j=0x000$ is black, $rgb_j=0x777$ is bright white. $0x700$ is bright red, $0x030$ medium green, $0x001$ is dark blue.\\


\subsection{Animations}
Animations consist of a background picture, a number of animation "cels", a positioning table for moving objects and a command sequence.

\beginpicture
\setcoordinatesystem units <5ex,5ex>
\setplotarea x from 0 to 6, y from 0 to 10
\plot 0 0 0 4 5 4 5 0 0 0 /
\plot 0 3 5 3 /
\plot 0 2 5 2 /
\plot 0 1 5 1 /
\put {Background} at 2.5 3.5
\put {Cels} at 2.5 2.5
\put {Animation objects} at 2.5 1.5
\put {Commands} at 2.5 0.5
\endpicture

The idea is, that one command selects a number of animation objects that are being triggered. Another commands defines how many frames are rendered with the selected objects. Each step of the animation has an X/Y coordinate and a cel number, to select the one to be drawn on top of the background picture.
\subsubsection{Background picture}
The format of the background picture is the same as the one for static pictures, except for the last two bytes.\\
\begin{tabular}{r|rl}
Bytes&&Description\\\hline
offset+5..offset+5&RGB(0)&RGB value pixel 0 (little endian)\\
offset+6..offset+7&RGB(1)&RGB value pixel 1 (little endian)\\
....&&\\
offset+36..offset+37&RGB(15)&RGB value pixel 15 (little endian)\\\hline
38..41&$datasize$& of the bitmap in bytes, MIXED ENDIAN\\
42..43&$width$& in pixels, little endian\\
44..45&$height$& in pixels, little endian\\
46..47&&UNKNOWN\\
48..47+datasize&bitmap\\\hline
48+datasize..49+datasize&"00 00"??&identifies the picture as background picture.\\
50+datasize..51+datasize&&UNKNOWN
\end{tabular}
\subsubsection{Animation cels}
The cels are sometimes transparent pictures that share their palette with the background picture.\\
\beginpicture
\setcoordinatesystem units <5ex,5ex>
\setplotarea x from 0 to 6, y from 0 to 7
\plot 0 0 0 7 5 7 5 0 0 0 /
\plot 0 6 5 6 /
\plot 0 4 5 4 /
\plot 0 2.5 5 2.5 /
\plot 0 2 5 2 /
\put {Number of cels} at 2.5 6.5
\put {Cel 1} at 2.5 5
\put {Cel 2} at 2.5 3
\put {Transparency 2} at 2.5 2.25
\put {Cel 3} at 2.5 1
\endpicture

Obviously, the cel block starts at $offset+50+datasize$.\\

\begin{tabular}{r|rl}
Bytes&&Description\\\hline
0..1&&Number of Cels (Little endian)\\\hline
2..5&$datasize^\prime$&datasize cel 1 in bytes (mixed endian)\\
6..7&$width^\prime$&width of cel 1 in pixels (little endian)\\
8..9&$height^\prime$&height of cel 1 in pixels (little endian)\\\hline
10..$datasize^\prime+11$&&Bitmap\\\hline
$datasize\prime+12$&$widthT$&Width of the Transparency Mask\\
$datasize\prime+14$&$heightT$&Height of the Transparency mask\\
\end{tabular}
The bitmap format is the same as for the static images. The RGB values are the same as the background picture's.\\

When the cel is transparent, $widthT=width^\prime$ and $heightT=height^\prime$, otherwise UNKOWN.

\subsubsection{Transparency}
\begin{tabular}{r|rl}
Bytes&&Description\\\hline
$datasize\prime+12$&$widthT$&Width of the Transparency Mask (little endian)\\
$datasize\prime+14$&$heightT$&Height of the Transparency mask (little endian)\\
$datasize\prime+16$&$sizeT$&Size of the transparency mask in bytes (little endian)\\
\end{tabular}

When the animation cel is transparent, the transparent pixels are marked by a "1" in the transparency mask. The format is MSB first.\\

When the amount of pixels in the cel picture is not divisible by 8, the last bits of a line are padding.\\

For a cel with 5 pixels width and 4 lines height=20 pixels, the transparency mask occupies 4 bytes:\\
\begin{tabular}{l|ll}
{\tt ttttt}&{\tt ppp}&Line 1\\\hline
{\tt ttttt}&{\tt ppp}&Line 2\\\hline
{\tt ttttt}&{\tt ppp}&Line 3\\\hline
{\tt ttttt}&{\tt ppp}&Line 4\\
\end{tabular}

whereas for a cel with 3 pixels width and 8 lines height=24 pixels, the transparency mask occupies 3 bytes:\\
\begin{tabular}{ll}
{\tt ttt}&Line 1\\\hline
{\tt ttt}&Line 2\\\hline
{\tt tt|t}&Line 3\\\hline
{\tt ttt}&Line 4\\\hline
{\tt ttt}&Line 5\\\hline
{\tt t|tt}&Line 6\\\hline
{\tt ttt}&Line 7\\\hline
{\tt ttt|}&Line 8\\\hline
\end{tabular}

Afterwards, 2 Bytes are UNKNOWN.

\subsubsection{Animation steps}

Between the cels and the animation steps, 2 bytes are UNKNOWN.\\

This block contains the animations. Basically, an animation is a list of cel numbers, and where to draw them: Each entry denotes the position and the number of the cel to be drawn within a single frame. The later the animation in the block, the later it is supposed to be drawn in the frame. I.E. it is in the foreground layer.\\

\begin{tabular}{rrr|rl}
Bytes&&&Description\\\hline
0..1&&&$anims$&Number of animations (little endian)\\\hline
&2..3&&&UNKNOWN\\
&4..5&&$steps1$&Number of steps for animation 1 (little endian)\\
&6..7&&&UNKNOWN\\
&&8..9&$x_{1,1}$&X-Coordinate for the first step (little endian)\\
&&10..11&$y_{1,1}$&Y-Coordinate for the first step (little endian)\\
&&12..13&$cel_{1,1}$&Number of the first cel (little endian)\\
&&14..15&&UNKNOWN\\\hline
&&16..17&$x_{1,2}$&X-Coordinate for the second step (little endian)\\
&&18..19&$y_{1,2}$&Y-Coordinate for the second step (little endian)\\
&&20..21&$cel_{1,2}$&Number of second cel (little endian)\\
&&22..23&&UNKNOWN\\\hline
...&&\\
&&2 bytes&$x_{1,steps1}$&X-Coordinate for the last step (little endian)\\
&&2 bytes&$y_{1,steps1}$&Y-Coordinate for the last step (little endian)\\
&&2 bytes&$cel_{1,steps1}$&Number of last cel (little endian)\\
&&2 bytes&&UNKNOWN\\\hline
&2 bytes&&$steps2$&Number of steps for animation 2 (little endian)\\
&2 bytes&&&UNKNOWN\\\hline
&&2 bytes&$x_{2,1}$&X-Coordinate for the first step (little endian)\\
&&2 bytes&$y_{2,1}$&Y-Coordinate for the first step (little endian)\\
&&2 bytes&$cel_{2,1}$&Number of last cel (little endian)\\
&&2 bytes&&UNKNOWN\\\hline
\end{tabular}

After the last step in the list, the animation loops back from the beginning. When the number of the cel is $=-1$, it is an end marker. The animation is no longer being shown.\\

$x$ and $y$ denote where the $cel$ is being drawn. Pixels outside the background image are not being drawn. When the transparency mask has a bit set $=1$, the pixel is not being drawn. \\

{\bf THE LAST ANIMATION STEP DOES NOT HAVE THE UNKNOWN VARIABLE!}

\subsubsection{Commands}
There are commands for selecting an animation. A command has up to 3 parameters. Each command and parameter is 1 Byte long.\\

The command line block begins with the number of commands, stored as a 16 bit signed integer.\\

\begin{tabular}{r|l}
Bytes&Description\\\hline
0..1&Number of commands (little endian).
\end{tabular}

Afterwards, the commands follow:

\begin{tabular}{l|l|l}
Command&Parameters&Description\\\hline
"0x00"&&End Marker\\
"0x01"&$animation$, $start$, $count$&Select an animation\\
"0x02"&$frames$&Render Frames\\
"0x03"&$addr_{lsb}$, $addr_{msb}$&jump to instruction $addr$\\
"0x04"&$delay_{lsb}$, $delay_{msb}$&pause for $delay$ cycles\\
"0x05"&$chance$, $addr_{lsb}$, $addr_{msb}$&in 1 in $chance$, jump to instruction $addr$\\
"0x06"&$addr_{lsb}$, $chance_{msb}$&jump to $addr$, if running\\
\end{tabular}

Currently, it is unknown if $addr$ is the instruction number, or its offset\\

Command "0x01" is referring to animation cel $x_{animation,start}$. Here, $animation=1$ is the first animation, $start=1$ is the first frame in the animation block.\\

\subsubsection{Rendering the animations}
The command list is parsed from beginning to end. In case command "0x01" occurs, the animation $animation$ is being selected. The first animation step being shown will be $start$. The animation itself will be running for $count$ frames. As long as more "0x01" commands occur, other animations are being selected.\\
Command "0x02" will start the animations. A total of $frames$ are being rendered. The first frame will start with the background image. The animations are being drawn one after another. The $cel_{anim,step}$ is drawn at the coordinates $x_{anim,step},\;y_{anim,step}$.\\
This is obviously being restricted by the size of the background image. In case the cel defines a transparency mask, this has to be reflected as well. \\
For the next frame $step$ is being increased. When $step$ reaches the end of the animation list, $step$ loops back to $step=1$.\\
In case $cel_{anim,step}==-1$, the animation has ended and should be hidden.\\

Once all the frames for Command "0x02" have been rendered, the selected animations will no longer be shown. The next command is being parsed, until the last command has been finished.\\

\section{DISK1.PIX and DISK2.PIX file format for the MS DOS version}
The graphics for the MS DOS version are stored in a total of 3 files: DISK1.PIX, DISK2.PIX and an individual index file, ending with a 4. (PAWN4, GUILD4, JINX4, FILE4, CORR4).\\
Within, images are stored as half-tone images. Meaning, that each pixel is in fact encoding 2 pixels. On a cathode ray screen, this produced the illusion of pictures with a richer amount of colours.
\subsection{Index file}
The index file (ending in a 4), contains the offsets into the DISK1.PIX, DISK2.PIX. It is always 256 bytes in size, and broken down into two sections. The first section of 128 bytes contains 32 values (signed 32 bit, little endian), used as offsets into the DISK1.PIX file. The section section uses the 32 values as offsets into the DISK2.PIX file.\\

\beginpicture
\setcoordinatesystem units <5ex,5ex>
\setplotarea x from 0 to 6, y from 0 to 6
\plot 0 0  3 0 3 3 0 3 0 0 /
\plot 0 3  3 3 3 6 0 6 0 3 /

\plot 0 0.5 3 0.5 /
\plot 0 1.0 3 1.0 /
\plot 0 1.5 3 1.5 /
\plot 0 2.0 3 2.0 /
\plot 0 2.5 3 2.5 /
\plot 0 3.5 3 3.5 /
\plot 0 4.0 3 4.0 /
\plot 0 4.5 3 4.5 /
\plot 0 5.0 3 5.0 /
\plot 0 5.5 3 5.5 /
\put {Section 2} at 5 1.5
\put {Section 1} at 5 4.5
\setshadegrid span <2pt>
\hshade 0 0 3  3 0 3 /
\setshadegrid span <1pt>
\hshade 3 0 3  6 0 3 /

\put {-1} at 1.5 5.75
\put {18} at 1.5 5.25
\put {-1} at 1.5 4.75
\put {-1} at 1.5 4.25
\put {-1} at 1.5 3.75
\put { 5} at 1.5 3.25

\put {13} at 1.5 2.75
\put {-1} at 1.5 2.25
\put {23} at 1.5 1.75
\put {42} at 1.5 1.25
\put {65} at 1.5 0.75
\put {-1} at 1.5 0.25
\endpicture


To read the offset, the $picnum$-th value is read from both sections. One of them has a $-1$, the other one has a valid offset.\\
\begin{tabular}{l@{$\;\;\;$}cc}
&{\bf Section1}&{\bf Section 2}\\
&-1&13\\
&18&-1\\
&-1&23\\
$\Rightarrow$&-1&42\\
&-1&65\\
\end{tabular}

It should be noted that the Title screen is typically picture number 30. If not, it is stored in offset 0 within the DISK1.PIX file.

\subsection{DISK1.PIX and DISK2.PIX}
Images in this format are encoded in three layers: The Huffman layer, the Repetition layer, and the XOR layer.\\
At the offset read from the index file, the image starts with a Huffman table. 

\begin{tabular}{r|rl}
Bytes&&Description\\\hline
0&$h$&Length of the Huffman tree (in bytes)\\
1..$h$&$H$&Huffman tree\\
$h+1$..$h+2$&$u$&Unpacked size (16 bit, big endian) in words\\
$h+3$..??&&Bitstream\\
\end{tabular}

The actual size of the unpacked, "unhuffed" buffer is given in 32 bit words. The size in bytes is $4*u+3$. Information like the rgb values, the height and the width is part of the unhuffed buffer.
\subsubsection{Layer 1: Huffman}
The Huffman tree is being read from the beginning, i.e. byte 1. The entries in the Huffman tree are either nodes or leaves. They are stored in pairs of two bytes. If the bitstream (which is being read MSB first) has a bit set, the left byte is being evaluated. Otherwise the right one.\\
In case the evaluated byte has bit 7 set, it is a leaf. The terminal symbol can be extracted by removing this bit. Thus, terminal symbols in the "unhuffed" buffer will only be 7 bits wide.\\
Otherwise it is a node, a link to the next entry within the tree: To translate it into a byte address $a$, the calculation $a=2 n_j+1$ has to be performed.\\
Then $b_{a+0}$ will be the next left node, and $b_{a+1}$ will be the next right entry.\\
Once the image has been "unhuffed", the data starts with a header.

\begin{tabular}{r|rl}
Bytes&&Description\\\hline
0&"0x77"&A magic marker\\
1&$m$&The number of half tone pixels\\
&& called "stipples"\\
2..3&$w$&Width (2x6 bit Big endian)\\
4..5&$h$&Height (2x6 bit Big endian)\\
6..21&$rgb(0),\dots,rgb(15)$&RGB values (3x2 bit)\\\hline
$22..22+2\cdot m$&&Stipple translation table\\
$22..22+m$&$p_l$&Left pixels\\
$22+m..22+2\cdot m$&$p_r$&right pixels\\\hline
$23+2\cdot m..23+2\cdot m+x$&$S$&Stipple string\\
\end{tabular}
$w$ and $h$ are stored as 2x6 bit big endian values, since terminal symbols in the Huffman tree can only be 7 bits wide. To translate them into "real" values can be done by
\begin{eqnarray*}
w&=&b_2*64+b_3\\
h&=&b_4*64+b_5\\
\end{eqnarray*}
The rgb values are stored as, MSB first: 2 bits 00, 2 bits red,  2 bits green and 2 bits blue.\\
Thus, 0x00 is black, 0x3f is bright white, 0x30 is bright red.

\subsubsection{Layer 2: Repetitions}
The stipple image is a string of stipples 

\begin{eqnarray*}
S&=&\left\{s_0,\dots,s_j,\dots,s_x\right\}
\end{eqnarray*}
This will be translated into 
\begin{eqnarray*}
T&=&\left\{t_0,\dots,t_k,\dots,t_y\right\}
\end{eqnarray*}
with $x\leq y$ and $y=w\cdot h-1$.\\

Each $s_j\in S$ can be one of three cases:
\begin{itemize}
\item{$s_j<m$ is a terminal stipple. $t_k=s_j$}
\item{$s_j=m$ and $s_{j-1}\ne m$ is a very special character. $s_j$ will be ignored, but $s_{j+1}$ will be used verbatim. $t_k=s_{j+1}$}
\item{$s_j>m$ and $s_{j-1}\ne m$ is a special character, denoting a repetition of the previous stipple. $t_{k},\dots,t_{k+s_j-m-1}=t_k{-1}$}
\end{itemize}

\subsection{Layer 3: XOR}
The translated image $T$ has the dimensions of the final image. However, it has to be XORed over two lines. This extra step resulted in a better packing ratio for the half tone images.\\
\begin{eqnarray*}
u_k&=&\left\{\begin{array}{l@{\;when\;}l}t_k \oplus t_{k-2\cdot w}&k\geq 2\cdot w\\t_k&k<2\cdot w\\\end{array}\right. %\}
\end{eqnarray*}
\subsection{Translation into pixels}
The image is a halftone image. Meaning, that each $u_k$ is actually encoding 2 rgb values. They can be restored from the stipple translation tables $p_l$ for the left and $p_r$ for the right pixel by
\begin{eqnarray*}
c_l&=&rgb\left[ p_l \left(u_k\right)\right]\\
c_r&=&rgb\left[ p_r \left(u_k\right)\right]\\
\end{eqnarray*}
\section{The Pseudo-GFX3 format}
Internally, dMagnetic is using a MaP3 format to combine the index file and the DISK1.PIX and DISK2.PIX in a single buffer.\\
The buffer starts with the magic word "MaP3". Then there is 4 bytes BIG endian for the length of the Index section (always =256).\\
Afterwards, 4 bytes of length for the DISK1.PIX file (BIG endian).\\
Afterwards, 4 bytes of length for the DISK2.PIX file (BIG endian).\\
\\
Then the Index file.\\
Then the DISK1.PIX file.\\
Then the DISK2.PIX file.\\
\chapter{Objects}
Objects are stored in a 14 byte structure. \\
\begin{tabular}{l|l|l}
Bytes&Bits&Description\\\hline
0..4&0..39&UNKNOWN\\
5&7..1&UNKNOWN\\
&0&is described\\
6&7&worn\\
&6&bodypart\\
&5..4&UNKNOWN\\
&3&room\\
&2&hidden\\
8..9&&parent object\\
10..13&&UNKNOWN\\
\end{tabular}

\chapter{Strings}
Strings are Huffman-Coded. The Decoding table is stored in the Strings2 section of the Mag-File. The Bitstreams are stored in the Strings1 section.
\section{Strings2: The Huffman Table}
The Strings2 section of the MAG-file has the following structure:

\beginpicture
\setcoordinatesystem units <5ex,5ex>
\setplotarea x from 0 to 6, y from 0 to 5
\plot 0 0 0 5 5 5 5 0 0 0 /
\plot 0 3 5 3 /
\plot 0 4 5 4 /
\setshadegrid span <1pt>
\hshade 4 0 5 5 0 5 /
\setshadegrid span <2pt>
\hshade 3 0 5 4 0 5 /
\put {"0" Nodes (128 Bytes)} at 2.5 4.5
\put {"1" Nodes (128 Bytes)} at 2.5 3.5
\put {Bitstream Pointers} at 2.5 2
\put {(WORD)} at 2.5 1.5
\put {\tiny 0} at 5.1 4.9
\put {\tiny 128} at 5.2 3.9
\put {\tiny 256} at 5.2 2.9
\put {\tiny string2size} at 5.5 0.2
\endpicture
The first 256 Bytes are reserved for the Nodes of the Huffman table. Afterwards, the Bitstream pointers, stored as 16 bit WORD values. They are denoting the start index within the Bitstream in the Strings1 section.
\section{Nodes}
The First 256 Bytes contain the Nodes for the Huffman Table. There are two types of nodes: Non-terminal and terminal ones. Terminal nodes have the highest Bit 7 set.

\begin{tabular}{|c|c|c|c|c|c|c|c|}
\tiny 7&\tiny 6&\tiny 5&\tiny 4&\tiny 3&\tiny 2&\tiny 1&\tiny 0\\\hline
0&\multicolumn{7}{c|}{node pointer}\\\hline
1&\multicolumn{7}{c|}{symbol}\\\hline
\end{tabular}
The index pointers

\chapter{Dictionary}
The dictionary contains the names of the objects. Most of the time, objects are using a single word. Since version 1(2?), some objects can be multiple words, such as "can of worms" or "one ferg".\\
The letters of the word are a..z, the end of a word is marked with Bit 7 being set.\\
In addition to this, the dictionary itself is broken down into banks. Two banks are searated by 0x82. The end of the dictionary is marked by a 0x81.\\
Version 4 saw the introduction of 0xA0. But its role is unclear to me.\\
\end{document}
